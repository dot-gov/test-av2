.-------------------------------.
| Breve documentazione analyzer |
'-------------------------------'

---------------------------------------------------
INFORMAZIONI GENERALI (ri-generazione del report e generazione di report su test parziali)
---------------------------------------------------

L'analyzer funziona in questo modo:
Rite ad ogni esecuzione produce in output uno yaml per l'analyzer.
L'analyzer opera sullo yaml, si salva dei dati in un database SQLite locale, e produce email di report.

Rite -> file report_for_analyzer.<timestamp>.<test>.yaml -> Analyzer -> Email di report

Lanciato senza paramentri l'analyzer process l'ultimo file di un SYSTEM_DAILY_SRV o SYSTEM_DAILY_FAST_SRV, o in alternativa e' possibile passare esplicitamente un file di report:

$python ./Rite/Analyzer/analyzer.py 

$python ./Rite/Analyzer/analyzer.py Rite/logs/150203/report_for_analyzer.150203-093221.SYSTEM_ELITE_FAST_SRV.yaml

Nel caso venga lanciato senza parametri, oltre al DAILY, l'anlyzer cerca gli ultimi UPDATE ed POSITIVE e li processa insieme, mentre quando viene lanciato passando un file non e' possibile fare analizzare file multipli.

Se non si e' certi su cosa sia stata fatta l'analisi, l'ultima riga dell'email di report indica il file processato.
Ad oggi non e' possibile processare files multipli contemporaneamente.

L'analyzer ha una memoria "persistente" (il db sqlite) ma evita di inserire piu' volte i dati di una singola esecuzione di rite, quindi e' possibile far ri-generare un report senza danni (riprocessando lo stesso file, viene ri-mandata un'email con lo stesso report).

Ri-eseguendo un test parziale (ad esempio: dopo il DAILY notturno, ri-eseguo l'Elite), vengono aggiunti i dati della nuova esecuzione del solo Elite, preservando gli altri test (es: Soldier) del Daily. I dati dell'Elite vengono anche confrontati con gli elite precedenti (ovvero in questo caso quelli del Daily).


---------------------------------------------------
INFORMAZIONI REALTIVE AL SALVATAGGIO DI ERRORI NOTI
---------------------------------------------------

L'analyzer funziona basandosi sull'analisi di sequenze di "commands" multipli, contenuti nel REPORT di un test. Il risultato di un test potrebbe quindi essere di questo tipo (semplificato):

CALL
ON_ERROR
SLEEP
CROP
PUSH
SLEEP
BUILD
CHECK_STATIC
SLEEP
CROP
END_CALL

Quindi anche "salvare" un errore consiste nel salvare una *sequenza* di errori di un test (i comandi non in errore non vengono considerati).

Per ogni command in errore, bisogna salvare vari dati, tra cui il "log" del comando. Il log del comando viene parsato come una regexp. I dati vanno salvati nel DB.

L'analyzer aiuta nell'inserimento producendo del codice python da copiare ed incollare direttamente in un file dell'Analyzer stesso. Il frammento di codice si trova nella sezione ERROR DETAILS sotto HELPER FOR MANUAL (nell'email) e va copiato in Rite/Analyzer/dbeport.py. Ad ogni avvio il sistema cancella tutti gli errori salvati e reinserisce quelli presenti nel file.

Esempio di un frammento semplice (un unico command in errore):
self.insert_summary_manual_error((u'VM_STATIC_SRV', u'avg15', u'CROP', 77, u'\\[13\\,\\ 37\\]', 'CROP', 0, u''), "--INSERT-COMMENT-HERE--")

Notare che il quinto elemento della tupla ha l'escaping di una regexp. Nel caso si voglia un match esatto, basta lasciare il testo cosi' com'e'. In questo caso pero' come in tutti i crop, non vanno considerati i numeri dei file di crop e quindi la riga andra' modificata cosi':
self.insert_summary_manual_error((u'VM_STATIC_SRV', u'avg15', u'CROP', 77, u'\\[.*\\]', 'CROP', 0, u''), "--INSERT-COMMENT-HERE--")
Ancora meglio e' usare una regexp del tipo: "^\\[.*\\]$" che verifica il match dell'inizio e della fine (cioe' non ci sarebbe un erroneo match con: '[abc]def' o 'xyz[abc]').

Inoltre e' importante inserire il commento:

self.insert_summary_manual_error((u'VM_STATIC_SRV', u'avg15', u'CROP', 77, u'\\[.*\\]', 'CROP', 0, u''), "AVG 15 give a False Positive crop in Static.")

Esistono casi multi-comando, nei quali anno inserite piu' righe come in questo esempio in cui la detetion produce fail nella BUID_SRV, poi CROP e alla fine CHECK_INFECTION. In questi casi il commento va replicato uguale su tutte le righe:

#eset7 soldier
        self.insert_summary_manual_error((u'VM_SOLDIER_SRV', u'eset7', u'BUILD_SRV', 25, u"\\[\\'\\+\\ SUCCESS\\ UPGRADED\\ SYNC\\'\\,\\ \\'\\+\\ ERROR\\:\\ \\[Error\\ 193\\]\\ \\%1\\ is\\ not\\ a\\ valid\\ Win32\\ application\\'\\]", 'FAILED', 0, u''), "ESET 7 Soldier (is an elite)")
        self.insert_summary_manual_error((u'VM_SOLDIER_SRV', u'eset7', u'CROP', 26, u'\\[.*\\]', 'CROP', 0, u''), "ESET 7 Soldier (is an elite)")
        self.insert_summary_manual_error((u'VM_SOLDIER_SRV', u'eset7', u'CHECK_INFECTION', 29, u'VM\\ is\\ INFECTED', 'FAILED', 0, u''), "ESET 7 Soldier (is an elite)")

---------------------------------------------------
POSSIBILI ERRORI
---------------------------------------------------

Se non arriva nessuna email, probabilmente il file report_for_analyzer*.yaml e' vuoto, perche' e' fallita o la generazione del report o il dump in yaml.

Nel secondo caso, i dati vengono stampati in console ed e' possibile quindi recuperarli dall'avmonitor.log, salvarli in un txt e correggerli. Di solito c'e' un qualche oggetto che viene erroneamente memorizzato dal command in un campo che dovrebbe contenere testo.
Basta quindi correggere il singolo errore, salvare il txt, aprire python e:
fi = open('f.txt',r)
fip = fi.read()
dat = eval(fip)
fiout = open('out.yaml', "a")
yaml.dump(dat, fiout)

$python ./Rite/Analyzer/analyzer.py out.yaml


---------------------------------------------------
CROP
---------------------------------------------------

Notare che ad ora i crop NON influenzano i risultati. I crop vengono analizzati solo se non sono "noti" e:
IF una parola rientra in blacklist vengono marcati come BAD
ELIF una parola rientra in crashlist (es: "stopped") vengono marcati come CRASH
ELIF se una parola e' in whitelist (es:update) vengono marcati come GOOD e non vengono allegati
ELSE vengono marcati come NO_TEXT o UNKNOWN

Se un errore e' noto ed ha dei crop, viene segnalato come noto e i crop non vengono analizzati.


---------------------------------------------------
TESSEREST
---------------------------------------------------
Tesserest e' il servizio web che processa le immagini usando tessethackt.
Tesserest usa FLASK (http://flask.pocoo.org/docs/0.10/) che si installa (vado a memoria) con: $sudo pip install Flask

L'applicazione flask (/Rite/Analyzer/tesserest.py) e' installata con wsgi in modo da avere un server sempre attivo e stabile.

Installazione:
sudo apt-get install libapache2-mod-wsgi

Poi va creato un file in /var/www/tesserest/tesserest.wsgi che contiene:
----------
import sys
sys.path.insert(0, '/home/avmonitor/Rite/Analyzer')
----------

I permessi del file e della cartella che contengono il file devono essere quelli con cui gira apache.

La configurazione di apache deve contenere:
in ports.conf:
Listen 55002
nel file dei default-sites (/etc/apache2/sites-available/000-default.conf) la seguente configurazione (da aggiungere ad eventuali altri VirtualHost):
<VirtualHost *:55002>
    ServerName 127.0.0.1

    WSGIScriptAlias / /var/www/tesserest/tesserest.wsgi

    <Directory /var/www/tesserest>
        WSGIScriptReloading On
        WSGIApplicationGroup %{GLOBAL}
        Order deny,allow
        Allow from all
    </Directory>
</VirtualHost>


Apache va fatto ripartire con sudo apachectl restart

Il servizio deve avere il permesso di scrittura nelle cartelle in cui vengono salvate files. In particolare  ~/logs/popup_thumbs/ deve essere scrivibile da www-data. Questa cartella va creata (il servizio non ha il permesso di crearla).
Il servizio non salva altri dati (a parte i files temporanei)

Il servizio si puo' testare con un browser puntando a:
http://172.20.20.192:55002/   (rite)
o
http://172.20.20.168:55002/   (puppet)


---------------------------------------------------
POPUP
---------------------------------------------------

***** NB: *****
Per usare il comando popup, e' necesario installare due librerie aggiuntive sulle vm, con il comando INSTALL_POPUP_LIBS (probabilmente andra' inserito nei comandi di installazione). Le librerie sono installate su tutte le vm di Rite.

Popup sostituito al Crop nelle procedure:
Elite
Soldier
Static
Positive Push virus

Nuove fasi di rilevamento popup inseriti:
Popup durante la fase scout (Elite)
Popup durante la fase scout (Soldier)
Popup con il Melt (le finestre degli installer sono in whitelist. Potrebbe mancare qualche finestra)

Popup probabilmente inseribili (dopo avere mappato le finestre):
Funzionali
Elite Demo
Executable document

Durante i test e' possibile:
* de-minimizzare la shell con il test per verificarne l'avanzamento
* usare il menu avvio
* usare explorer
* usare altre applicazioni di Windows (calc, internet explorer, image viewer)
senza che venga scatenato il Popup.
Questo e' sperimentale, nel senso che e' stato testato bene solo su windows 7.

Se si vuole scatenare il popup volontariamente si puo' usare Paint. Se si vuole scatenare un popup con un testo specifico si puo' usare il la funzione testo di paint ed inserire un testo apposito (Es: "virus detected").