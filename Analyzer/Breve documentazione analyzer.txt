.-------------------------------.
| Breve documentazione analyzer |
'-------------------------------'

---------------------------------------------------
INFORMAZIONI GENERALI (ri-generazione del report e generazione di report su test parziali)
---------------------------------------------------

L'analyzer funziona in questo modo:
Rite ad ogni esecuzione produce in output uno yaml per l'analyzer.
L'analyzer opera sullo yaml, si salva dei dati in un database SQLite locale, e produce email di report.

Rite -> file report_for_analyzer.<timestamp>.<test>.yaml -> Analyzer -> Email di report

Lanciato senza paramentri l'analyzer process l'ultimo file di un SYSTEM_DAILY_SRV o SYSTEM_DAILY_FAST_SRV, o in alternativa e' possibile passare esplicitamente un file di report:

$python ./Rite/Analyzer/analyzer.py 

$python ./Rite/Analyzer/analyzer.py Rite/logs/150203/report_for_analyzer.150203-093221.SYSTEM_ELITE_FAST_SRV.yaml

Nel caso venga lanciato senza parametri, oltre al DAILY, l'anlyzer cerca gli ultimi UPDATE ed POSITIVE e li processa insieme, mentre quando viene lanciato passando un file non e' possibile fare analizzare file multipli.

Se non si e' certi su cosa sia stata fatta l'analisi, l'ultima riga dell'email di report indica il file processato.
Ad oggi non e' possibile processare files multipli contemporaneamente.

L'analyzer ha una memoria "persistente" (il db sqlite) ma evita di inserire piu' volte i dati di una singola esecuzione di rite, quindi e' possibile far ri-generare un report senza danni (riprocessando lo stesso file, viene ri-mandata un'email con lo stesso report).

Ri-eseguendo un test parziale (ad esempio: dopo il DAILY notturno, ri-eseguo l'Elite), vengono aggiunti i dati della nuova esecuzione del solo Elite, preservando gli altri test (es: Soldier) del Daily. I dati dell'Elite vengono anche confrontati con gli elite precedenti (ovvero in questo caso quelli del Daily).


---------------------------------------------------
INFORMAZIONI REALTIVE AL SALVATAGGIO DI ERRORI NOTI
---------------------------------------------------

L'analyzer funziona basandosi sull'analisi di sequenze di "commands" multipli, contenuti nel REPORT di un test. Il risultato di un test potrebbe quindi essere di questo tipo (semplificato):

CALL
ON_ERROR
SLEEP
CROP
PUSH
SLEEP
BUILD
CHECK_STATIC
SLEEP
CROP
END_CALL

Quindi anche "salvare" un errore consiste nel salvare una *sequenza* di errori di un test (i comandi non in errore non vengono considerati).

Per ogni command in errore, bisogna salvare vari dati, tra cui il "log" del comando. Il log del comando viene parsato come una regexp. I dati vanno salvati nel DB.

L'analyzer aiuta nell'inserimento producendo del codice python da copiare ed incollare direttamente in un file dell'Analyzer stesso. Il frammento di codice si trova nella sezione ERROR DETAILS sotto HELPER FOR MANUAL (nell'email) e va copiato in Rite/Analyzer/dbeport.py. Ad ogni avvio il sistema cancella tutti gli errori salvati e reinserisce quelli presenti nel file.

Esempio di un frammento semplice (un unico command in errore):
self.insert_summary_manual_error((u'VM_STATIC_SRV', u'avg15', u'CROP', 77, u'\\[13\\,\\ 37\\]', 'CROP', 0, u''), "--INSERT-COMMENT-HERE--")

Notare che il quinto elemento della tupla ha l'escaping di una regexp. Nel caso si voglia un match esatto, basta lasciare il testo cosi' com'e'. In questo caso pero' come in tutti i crop, non vanno considerati i numeri dei file di crop e quindi la riga andra' modificata cosi':
self.insert_summary_manual_error((u'VM_STATIC_SRV', u'avg15', u'CROP', 77, u'\\[.*\\]', 'CROP', 0, u''), "--INSERT-COMMENT-HERE--")

Inoltre e' importante inserire il commento:

self.insert_summary_manual_error((u'VM_STATIC_SRV', u'avg15', u'CROP', 77, u'\\[.*\\]', 'CROP', 0, u''), "AVG 15 give a False Positive crop in Static.")

Esistono casi multi-comando, nei quali anno inserite piu' righe come in questo esempio in cui la detetion produce fail nella BUID_SRV, poi CROP e alla fine CHECK_INFECTION. In questi casi il commento va replicato uguale su tutte le righe:

#eset7 soldier
        self.insert_summary_manual_error((u'VM_SOLDIER_SRV', u'eset7', u'BUILD_SRV', 25, u"\\[\\'\\+\\ SUCCESS\\ UPGRADED\\ SYNC\\'\\,\\ \\'\\+\\ ERROR\\:\\ \\[Error\\ 193\\]\\ \\%1\\ is\\ not\\ a\\ valid\\ Win32\\ application\\'\\]", 'FAILED', 0, u''), "ESET 7 Soldier (is an elite)")
        self.insert_summary_manual_error((u'VM_SOLDIER_SRV', u'eset7', u'CROP', 26, u'\\[.*\\]', 'CROP', 0, u''), "ESET 7 Soldier (is an elite)")
        self.insert_summary_manual_error((u'VM_SOLDIER_SRV', u'eset7', u'CHECK_INFECTION', 29, u'VM\\ is\\ INFECTED', 'FAILED', 0, u''), "ESET 7 Soldier (is an elite)")

---------------------------------------------------
POSSIBILI ERRORI
---------------------------------------------------

Se non arriva nessuna email, probabilmente il file report_for_analyzer*.yaml e' vuoto, perche' e' fallita o la generazione del report o il dump in yaml.

Nel secondo caso, i dati vengono stampati in console ed e' possibile quindi recuperarli dall'avmonitor.log, salvarli in un txt e correggerli. Di solito c'e' un qualche oggetto che viene erroneamente memorizzato dal command in un campo che dovrebbe contenere testo.
Basta quindi correggere il singolo errore, salvare il txt, aprire python e:
fi = open('f.txt',r)
fip = fi.read()
dat = eval(fip)
fiout = open('out.yaml', "a")
yaml.dump(dat, fiout)

$python ./Rite/Analyzer/analyzer.py out.yaml


---------------------------------------------------
CROP
---------------------------------------------------

Notare che ad ora i crop NON influenzano i risultati. I crop vengono analizzati solo se non sono "noti" e:
IF una parola rientra in blacklist vengono marcati come BAD
ELIF una parola rientra in crashlist (es: "stopped") vengono marcati come CRASH
ELIF se una parola e' in whitelist (es:update) vengono marcati come GOOD e non vengono allegati
ELSE vengono marcati come NO_TEXT o UNKNOWN

Se un errore e' noto ed ha dei crop, viene segnalato come noto e i crop non vengono analizzati.


---------------------------------------------------
TESSEREST
---------------------------------------------------
Tesserest e' il servizio web che processa le immagini usando tessethackt.
Tesserest usa FLASK (http://flask.pocoo.org/docs/0.10/) che si installa (vado a memoria) con: $sudo pip install Flask

L'applicazione flask (/Rite/Analyzer/tesserest.py) e' installata con wsgi in modo da avere un server sempre attivo e stabile.

Installazione:
sudo apt-get install libapache2-mod-wsgi

Poi va creato un file in /var/www/tesserest/tesserest.wsgi che contiene:
----------
import sys
sys.path.insert(0, '/home/avmonitor/Rite/Analyzer')
----------

I permessi del file e della cartella che contengono il file devono essere quelli con cui gira apache.

La configurazione di apache deve contenere:
in ports.conf:
Listen 55002
nel file dei default-sites (/etc/apache2/sites-available/000-default.conf) la seguente configurazione (da aggiungere ad eventuali altri VirtualHost):
<VirtualHost *:55002>
    ServerName 127.0.0.1

    WSGIScriptAlias / /var/www/tesserest/tesserest.wsgi

    <Directory /var/www/tesserest>
        WSGIScriptReloading On
        WSGIApplicationGroup %{GLOBAL}
        Order deny,allow
        Allow from all
    </Directory>
</VirtualHost>


Apache va fatto ripartire con sudo apachectl restart

Il servizio si puo' testare con un browser puntando a:
http://172.20.20.192:55002/   (rite)
o
http://172.20.20.168:55002/   (puppet)
